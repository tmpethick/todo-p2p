(function(modules, entryId$$) {
             var require = (function () {
  require.__byId = __byId;
  return require;

  function require(name) {
    var scope$$ = window.__livereactload$$;
    var myId = arguments.length > 1 ? arguments[arguments.length - 1] : null;
    return __byId(moduleKey(scope$$, myId, name), false);
  }

  function __byId(id, isReload) {
    var oldRequire = typeof window.require === "function" ? window.require : null;
    var scope$$ = window.__livereactload$$;
    var _module = findModule(scope$$, id);

    if (_module) {
      scope$$.exports[_module.id] = !isReload ? scope$$.exports[_module.id] || {} : {};
      var _exports2 = scope$$.exports[_module.id];
      var mod = {
        exports: _exports2,
        onReload: function onReload(fn) {
          scope$$.reloaders[_module.file] = fn;
        }
      };
      // TODO: there should be still one argument to pass.. figure out which is it
      var oldReloader = scope$$.reloaders[_module.file];
      _module[0].apply(this, [require, mod, _exports2, _module[0], scope$$.modules, scope$$.exports]);
      scope$$.exports[_module.id] = mod.exports;

      if (isReload && typeof oldReloader === "function") {
        var accept = oldReloader.call();
        if (accept === true) {
          throw { accepted: true };
        }
      }
      return mod.exports;
    } else if (oldRequire) {
      return oldRequire.apply(undefined, arguments);
    } else {
      var e = new Error("Module not found: " + name);
      e.code = "MODULE_NOT_FOUND";
      throw e;
    }
  }

  function moduleKey(_ref, callerId, name) {
    var modules = _ref.modules;

    var _ref2 = modules[callerId] || {};

    var _ref2$deps = _ref2.deps;
    var deps = _ref2$deps === undefined ? {} : _ref2$deps;

    return deps[name];
  }

  // resolve module so that de-duplicated modules are skipped and the
  // original module is returned
  function findModule(_ref3, id) {
    var modules = _ref3.modules;

    var mod = modules[id];
    if (mod) {
      if (mod.dedupeIndex) {
        var orig = null;
        Object.keys(modules).forEach(function (id) {
          if (modules[id].index === mod.dedupeIndex) {
            orig = findModule({ modules: modules }, id);
          }
        });
        return orig;
      } else {
        return mod;
      }
    }
  }
})();;

       window.__livereactload$$ = {
         require: require,
         modules: modules,
         exports: {},
         reloaders: {},
         initModules: initModules
       };

       initModules();

       function initModules() {
         var allExports = window.__livereactload$$.exports;
         var modules    = window.__livereactload$$.modules;
         // initialize Browserify compatibility
         Object.keys(modules).forEach(function(id) {
           modules[id][0] = (function(require, module, exports) {
             if (!modules[id].__inited) {
               modules[id].__inited = true
               var __init = new Function("require", "module", "exports", modules[id].source);
               var _require = (function() { return require.apply(require, Array.prototype.slice.call(arguments).concat(id)); });
               __init(_require, module, exports, arguments[3], arguments[4], arguments[5], arguments[6]);
             }
           })
           modules[id][1] = modules[id].deps;
         })
       }
             (function() {
               require("livereactload/client", entryId$$).call(null,{"port":4474,"host":"localhost"});
require("./app.js", entryId$$);
             })();
           })({
  "1": {
    "id": 1,
    "index": 1,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/js/___livereactload_entry.js",
    "source": "require(\"livereactload/client\", entryId$$).call(null,{\"port\":4474,\"host\":\"localhost\"});\nrequire(\"./app.js\", entryId$$);",
    "deps": {
      "livereactload/client": 4,
      "./app.js": 2
    },
    "entry": true,
    "hash": "7a2ed8544a7ee7bbfd52b57cbb204d8c"
  },
  "2": {
    "id": 2,
    "index": 2,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/js/app.js",
    "source": "'use strict';\n\nvar _utils = require('./utils');\n\nvar _uuidJs = require('uuid-js');\n\nvar _uuidJs2 = _interopRequireDefault(_uuidJs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar uuid4 = _uuidJs2.default.create();\n\nvar peer = new Peer(uuid4.toString(), { host: 'localhost', port: 9000, path: '/' });\n\npeer.listAllPeers(function (peers) {\n  console.log(peers);\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBR0EsSUFBSSxLQUFLLEdBQUcsaUJBQUssTUFBTSxFQUFFLENBQUM7O0FBRTFCLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFDLENBQUMsQ0FBQzs7QUFFbEYsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFTLEtBQUssRUFBRTtBQUNoQyxTQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQ3BCLENBQUMsQ0FBQyIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3Rlc3R9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgVVVJRCBmcm9tICd1dWlkLWpzJztcblxudmFyIHV1aWQ0ID0gVVVJRC5jcmVhdGUoKTtcblxudmFyIHBlZXIgPSBuZXcgUGVlcih1dWlkNC50b1N0cmluZygpLCB7aG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IDkwMDAsIHBhdGg6ICcvJ30pO1xuXG5wZWVyLmxpc3RBbGxQZWVycyhmdW5jdGlvbihwZWVycykge1xuICBjb25zb2xlLmxvZyhwZWVycyk7XG59KTtcbiJdfQ==",
    "deps": {
      "./utils": 3,
      "uuid-js": 12
    },
    "hash": "d016ed9058c0f6bc76db1cc9d92d26a7"
  },
  "3": {
    "id": 3,
    "index": 3,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/js/utils.js",
    "source": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.test = undefined;\n\nvar _yocto = require('yocto');\n\nvar _yocto2 = _interopRequireDefault(_yocto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar db = _yocto2.default.db({ uuid: 'id' });\n\nvar test = exports.test = \"test\";\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFJLEVBQUUsR0FBRyxnQkFBTSxFQUFFLENBQUMsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQzs7QUFFekIsSUFBSSxJQUFJLFdBQUosSUFBSSxHQUFHLE1BQU0sQ0FBQyIsImZpbGUiOiJ1dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB5b2N0byBmcm9tICd5b2N0byc7XG5cbnZhciBkYiA9IHlvY3RvLmRiKHt1dWlkOiAnaWQnfSk7XG5cbmV4cG9ydCB2YXIgdGVzdCA9IFwidGVzdFwiO1xuIl19",
    "deps": {
      "yocto": 13
    },
    "hash": "348db16d51f3aafe04604efc7c77766b"
  },
  "4": {
    "id": 4,
    "index": 4,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/client.js",
    "source": "\nmodule.exports = require(\"./lib/client/main.js\")\n",
    "deps": {
      "./lib/client/main.js": 7
    },
    "hash": "e497cd554968c27200a06c783e327db6"
  },
  "5": {
    "id": 5,
    "index": 5,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/client/console.js",
    "source": "Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.info = info;\nexports.warn = warn;\n\nfunction info(msg) {\n  console.info(\"LiveReactload ::\", msg);\n}\n\nfunction warn(msg) {\n  console.warn(\"LiveReactload ::\", msg);\n}",
    "deps": {},
    "hash": "c1346ae9c96c8d7e3f17a624faa71539"
  },
  "6": {
    "id": 6,
    "index": 6,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/client/handleChange.js",
    "source": "Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = handleChanges;\n\nvar _require = require(\"./reloadUtils\");\n\nvar diff = _require.diff;\nvar patchMetaData = _require.patchMetaData;\n\nvar _require2 = require(\"./console\");\n\nvar info = _require2.info;\nvar warn = _require2.warn;\n\nvar _require3 = require(\"../common\");\n\nvar isPlainObj = _require3.isPlainObj;\nvar values = _require3.values;\nvar find = _require3.find;\n\nfunction handleChanges(scope$$, _ref) {\n  var newModules = _ref.modules;\n  var newEntryId = _ref.entryId;\n  var modules = scope$$.modules;\n  var __require = scope$$.require;\n\n  var modulesToReload = diff(modules, newModules, newEntryId);\n  patchMetaData(scope$$, newModules);\n\n  if (modulesToReload.length === 0) {\n    info(\"Nothing to patch\");\n    return;\n  }\n\n  var patch = modulesToReload.map(function (mod) {\n    return {\n      id: mod.id,\n      changed: mod.changed,\n      file: mod.file,\n      source: mod.source,\n      parents: mod.parents.map(Number),\n      isNew: mod.isNew\n    };\n  });\n\n  var propagationGuards = {};\n  patch.forEach(function (_ref2) {\n    var id = _ref2.id;\n    var changed = _ref2.changed;\n    var parents = _ref2.parents;\n\n    propagationGuards[id] = (propagationGuards[id] || 0) + (changed ? 1 : 0);\n    parents.forEach(function (p) {\n      return propagationGuards[p] = (propagationGuards[p] || 0) + 1;\n    });\n  });\n\n  info(\"Apply patch\");\n  try {\n    patch.forEach(function (_ref3) {\n      var id = _ref3.id;\n      var file = _ref3.file;\n      var parents = _ref3.parents;\n      var isNew = _ref3.isNew;\n\n      if (propagationGuards[id] > 0) {\n        if (isNew) {\n          console.log(\" > Add new module  ::\", file);\n        } else {\n          console.log(\" > Patch module    ::\", file);\n        }\n\n        var reloadedExports = undefined,\n            accepted = false;\n        try {\n          // ATTENTION: must use scope object because it has been mutated during \"pathMetaData\"\n          delete scope$$.exports[id];\n          scope$$.modules[id].__inited = false;\n          reloadedExports = __require.__byId(id, true);\n        } catch (e) {\n          if (e.accepted) {\n            console.log(\" > Manually accepted\");\n            accepted = true;\n          } else {\n            console.error(e);\n            warn(\"Abort patching\");\n            throw { aborted: true };\n          }\n        }\n\n        if (!isNew && (accepted || isStoppable(reloadedExports || {}))) {\n          preventPropagation(parents);\n        }\n      } else {\n        // this will prevent propagation to ancestor files\n        preventPropagation(parents);\n      }\n    });\n    info(\"Patching complete\");\n  } catch (e) {\n    if (!e.aborted) {\n      console.error(e);\n    }\n  }\n\n  function preventPropagation(parents) {\n    parents.forEach(function (p) {\n      var parent = find(patch, function (_ref4) {\n        var id = _ref4.id;\n        return id === p;\n      });\n      if (parent) {\n        propagationGuards[parent.id]--;\n      }\n    });\n  }\n}\n\nfunction isStoppable(exports) {\n  if (isProxied(exports)) {\n    return true;\n  } else if (isPlainObj(exports)) {\n    return !!find(values(exports), isProxied);\n  }\n  return false;\n}\n\nfunction isProxied(o) {\n  return o && !!o.__reactPatchProxy;\n}\nmodule.exports = exports[\"default\"];",
    "deps": {
      "./console": 5,
      "../common": 10,
      "./reloadUtils": 8
    },
    "hash": "b39266feab4d6033f94707a39c4017bc"
  },
  "7": {
    "id": 7,
    "index": 7,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/client/main.js",
    "source": "Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = client;\nvar startClient = require(\"./startClient\");\nvar handleChange = require(\"./handleChange\");\n\nvar _require = require(\"./console\");\n\nvar info = _require.info;\n\nfunction client(opts) {\n  var start = arguments.length <= 1 || arguments[1] === undefined ? startClient : arguments[1];\n\n  var scope$$ = window.__livereactload$$;\n  scope$$.options = opts;\n  start(scope$$, {\n    change: function change(msg) {\n      info(\"Bundle changed\");\n      handleChange(scope$$, msg.data);\n    },\n    patch: function patch(msg) {}\n  });\n}\n\nmodule.exports = exports[\"default\"];",
    "deps": {
      "./console": 5,
      "./startClient": 9,
      "./handleChange": 6
    },
    "hash": "3e8211be523e5c4cdc210de68046744d"
  },
  "8": {
    "id": 8,
    "index": 8,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/client/reloadUtils.js",
    "source": "Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.patchMetaData = patchMetaData;\nexports.diff = diff;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _require = require(\"../common\");\n\nvar keys = _require.keys;\nvar values = _require.values;\nvar extend = _require.extend;\nvar sortBy = _require.sortBy;\nvar pairs = _require.pairs;\n\nfunction patchMetaData(scope$$, newModules) {\n  var modules = scope$$.modules;\n  var exports = scope$$.exports;\n\n  var oldModulesByFile = {};\n  values(modules).forEach(function (mod) {\n    return oldModulesByFile[mod.file] = mod;\n  });\n\n  var rearrangedExports = {};\n  keys(newModules).forEach(function (id) {\n    var oldModule = oldModulesByFile[newModules[id].file];\n    if (oldModule) {\n      rearrangedExports[id] = exports[oldModule.id];\n      newModules[id].__inited = true;\n    }\n  });\n\n  scope$$.exports = rearrangedExports;\n  scope$$.modules = newModules;\n  scope$$.initModules();\n}\n\nfunction diff(modules, newModules, newEntryId) {\n  var oldModulesByFile = {};\n  values(modules).forEach(function (mod) {\n    return oldModulesByFile[mod.file] = mod;\n  });\n\n  var changedModules = values(newModules).filter(function (_ref) {\n    var entry = _ref.entry;\n    var file = _ref.file;\n    var hash = _ref.hash;\n\n    return !oldModulesByFile[file] || oldModulesByFile[file].hash !== hash;\n  });\n\n  // resolve reverse dependencies so that we can calculate\n  // weights for correct reloading order\n  var dependencies = {};\n  function resolveDeps(mod) {\n    var deps = values(mod.deps);\n    dependencies[mod.id] = deps;\n    deps.forEach(function (d) {\n      if (!dependencies[d] && newModules[d]) resolveDeps(newModules[d]);\n    });\n  }\n  resolveDeps(newModules[newEntryId]);\n\n  var parents = {};\n  pairs(dependencies).forEach(function (_ref2) {\n    var _ref22 = _slicedToArray(_ref2, 2);\n\n    var id = _ref22[0];\n    var deps = _ref22[1];\n\n    deps.forEach(function (d) {\n      return parents[d] = [id].concat(_toConsumableArray(parents[d] || []));\n    });\n  });\n\n  // idea behind weighting: each file has initial weight = 1\n  // each file gets also the sum of its dependency weights\n  // finally files are sorted by weight => smaller ones must\n  // be reloaded before their dependants (bigger weights)\n  var weights = {};\n  var hasChanged = {};\n  changedModules.forEach(function (_ref3) {\n    var id = _ref3.id;\n\n    hasChanged[id] = true;\n    addWeightsStartingFrom(id, weights, parents);\n  });\n\n  var modulesToReload = sortBy(pairs(weights), function (_ref4) {\n    var _ref42 = _slicedToArray(_ref4, 2);\n\n    var _ = _ref42[0];\n    var weight = _ref42[1];\n    return weight;\n  }).map(function (_ref5) {\n    var _ref52 = _slicedToArray(_ref5, 1);\n\n    var id = _ref52[0];\n    return newModules[id];\n  }).filter(function (module) {\n    return !!module && !module.entry;\n  }).map(function (module) {\n    return _extends({}, module, {\n      changed: !!hasChanged[module.id],\n      parents: parents[module.id] || [],\n      isNew: !oldModulesByFile[module.file]\n    });\n  });\n\n  return modulesToReload;\n\n  function addWeightsStartingFrom(id, weights, parents) {\n    var visited = {};\n    weightRecur(id, 1);\n    function weightRecur(id, w) {\n      if (visited[id]) {\n        // prevent circular dependency stack overflow\n        return;\n      }\n      var dependants = parents[id] || [];\n      visited[id] = true;\n      weights[id] = (weights[id] || 0) + w;\n      dependants.forEach(function (d) {\n        return weightRecur(d, weights[id] + 1);\n      });\n    }\n  }\n}",
    "deps": {
      "../common": 10
    },
    "hash": "25862872bcb5fe29b724ddd43e15d931"
  },
  "9": {
    "id": 9,
    "index": 9,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/client/startClient.js",
    "source": "Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = startClient;\nvar WebSocket = require(\"ws\");\n\nvar _require = require(\"./console\");\n\nvar info = _require.info;\n\nvar noop = function noop() {};\n\nfunction startClient(scope$$, onMsg) {\n  if (!scope$$.ws) {\n    (function () {\n      var url = makeHostUrl(scope$$);\n      info(\"Connect reload client to \" + url);\n\n      var ws = new WebSocket(url);\n      ws.onopen = function () {\n        return info(\"WebSocket client listening for changes...\");\n      };\n\n      ws.onmessage = function (m) {\n        var msg = JSON.parse(m.data);\n        var res = (onMsg[msg.type] || noop)(msg);\n        if (res) {\n          ws.send(JSON.stringify(res));\n        }\n      };\n\n      scope$$.ws = ws;\n    })();\n  }\n}\n\nfunction makeHostUrl(_ref) {\n  var _ref$options = _ref.options;\n  var host = _ref$options.host;\n  var port = _ref$options.port;\n\n  var protocol = window.location.protocol === \"https:\" ? \"wss\" : \"ws\";\n  return protocol + \"://\" + host + \":\" + port;\n}\nmodule.exports = exports[\"default\"];",
    "deps": {
      "./console": 5,
      "ws": 11
    },
    "hash": "864f8de9d51e163a2b62286792371a56"
  },
  "10": {
    "id": 10,
    "index": 10,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/lib/common.js",
    "source": "Object.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.keys = keys;\nexports.values = values;\nexports.pairs = pairs;\nexports.sortBy = sortBy;\nexports.extend = extend;\nexports.find = find;\nexports.isPlainObj = isPlainObj;\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction values(obj) {\n  return keys(obj).map(function (k) {\n    return obj[k];\n  });\n}\n\nfunction pairs(obj) {\n  return keys(obj).map(function (k) {\n    return [k, obj[k]];\n  });\n}\n\nfunction sortBy(arr, comp) {\n  return arr.slice().sort(function (a, b) {\n    return comp(a) < comp(b) ? -1 : comp(a) > comp(b) ? 1 : 0;\n  });\n}\n\nfunction extend(dest) {\n  for (var _len = arguments.length, objs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objs[_key - 1] = arguments[_key];\n  }\n\n  objs.forEach(function (obj) {\n    var o = obj || {};\n    keys(o).forEach(function (k) {\n      if (o.hasOwnProperty(k)) {\n        dest[k] = o[k];\n      }\n    });\n  });\n  return dest;\n}\n\nfunction find(arr, predicate) {\n  var results = (arr || []).filter(predicate);\n  return results.length ? results[0] : undefined;\n}\n\nfunction isPlainObj(o) {\n  return typeof o == 'object' && o.constructor == Object;\n}",
    "deps": {},
    "hash": "2dd5bb1a473ce8ca0c7f8761d262b4fe"
  },
  "11": {
    "id": 11,
    "index": 11,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/livereactload/node_modules/ws/lib/browser.js",
    "source": "\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n",
    "deps": {},
    "hash": "1e2bdb9308fb7f3575a514332777131f"
  },
  "12": {
    "id": 12,
    "index": 12,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/uuid-js/lib/uuid.js",
    "source": "/*\n * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate\n * TimeUUID based on dates for range selections.\n * @see http://www.ietf.org/rfc/rfc4122.txt\n **/\n\nfunction UUIDjs() {\n};\n\nUUIDjs.maxFromBits = function(bits) {\n  return Math.pow(2, bits);\n};\n\nUUIDjs.limitUI04 = UUIDjs.maxFromBits(4);\nUUIDjs.limitUI06 = UUIDjs.maxFromBits(6);\nUUIDjs.limitUI08 = UUIDjs.maxFromBits(8);\nUUIDjs.limitUI12 = UUIDjs.maxFromBits(12);\nUUIDjs.limitUI14 = UUIDjs.maxFromBits(14);\nUUIDjs.limitUI16 = UUIDjs.maxFromBits(16);\nUUIDjs.limitUI32 = UUIDjs.maxFromBits(32);\nUUIDjs.limitUI40 = UUIDjs.maxFromBits(40);\nUUIDjs.limitUI48 = UUIDjs.maxFromBits(48);\n\n// Returns a random integer between min and max\n// Using Math.round() will give you a non-uniform distribution!\n// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nUUIDjs.randomUI04 = function() {\n  return getRandomInt(0, UUIDjs.limitUI04-1);\n};\nUUIDjs.randomUI06 = function() {\n  return getRandomInt(0, UUIDjs.limitUI06-1);\n};\nUUIDjs.randomUI08 = function() {\n  return getRandomInt(0, UUIDjs.limitUI08-1);\n};\nUUIDjs.randomUI12 = function() {\n  return getRandomInt(0, UUIDjs.limitUI12-1);\n};\nUUIDjs.randomUI14 = function() {\n  return getRandomInt(0, UUIDjs.limitUI14-1);\n};\nUUIDjs.randomUI16 = function() {\n  return getRandomInt(0, UUIDjs.limitUI16-1);\n};\nUUIDjs.randomUI32 = function() {\n  return getRandomInt(0, UUIDjs.limitUI32-1);\n};\nUUIDjs.randomUI40 = function() {\n  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);\n};\nUUIDjs.randomUI48 = function() {\n  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);\n};\n\nUUIDjs.paddedString = function(string, length, z) {\n  string = String(string);\n  z = (!z) ? '0' : z;\n  var i = length - string.length;\n  for (; i > 0; i >>>= 1, z += z) {\n    if (i & 1) {\n      string = z + string;\n    }\n  }\n  return string;\n};\n\nUUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {\n  this.version = (timeHiAndVersion >> 12) & 0xF;\n  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)\n             + '-'\n             + UUIDjs.paddedString(timeMid.toString(16), 4)\n             + '-'\n             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)\n             + '-'\n             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)\n             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)\n             + '-'\n             + UUIDjs.paddedString(node.toString(16), 12);\n  return this;\n};\n\nUUIDjs.prototype.toString = function() {\n  return this.hex;\n};\nUUIDjs.prototype.toURN = function() {\n  return 'urn:uuid:' + this.hex;\n};\n\nUUIDjs.prototype.toBytes = function() {\n  var parts = this.hex.split('-');\n  var ints = [];\n  var intPos = 0;\n  for (var i = 0; i < parts.length; i++) {\n    for (var j = 0; j < parts[i].length; j+=2) {\n      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);\n    }\n  }\n  return ints;\n};\n\nUUIDjs.prototype.equals = function(uuid) {\n  if (!(uuid instanceof UUID)) {\n    return false;\n  }\n  if (this.hex !== uuid.hex) {\n    return false;\n  }\n  return true;\n};\n\nUUIDjs.getTimeFieldValues = function(time) {\n  var ts = time - Date.UTC(1582, 9, 15);\n  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;\n  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,\n            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };\n};\n\nUUIDjs._create4 = function() {\n  return new UUIDjs().fromParts(\n    UUIDjs.randomUI32(),\n    UUIDjs.randomUI16(),\n    0x4000 | UUIDjs.randomUI12(),\n    0x80   | UUIDjs.randomUI06(),\n    UUIDjs.randomUI08(),\n    UUIDjs.randomUI48()\n  );\n};\n\nUUIDjs._create1 = function() {\n  var now = new Date().getTime();\n  var sequence = UUIDjs.randomUI14();\n  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();\n  var tick = UUIDjs.randomUI04();\n  var timestamp = 0;\n  var timestampRatio = 1/4;\n\n  if (now != timestamp) {\n    if (now < timestamp) {\n      sequence++;\n    }\n    timestamp = now;\n    tick = UUIDjs.randomUI04();\n  } else if (Math.random() < timestampRatio && tick < 9984) {\n    tick += 1 + UUIDjs.randomUI04();\n  } else {\n    sequence++;\n  }\n\n  var tf = UUIDjs.getTimeFieldValues(timestamp);\n  var tl = tf.low + tick;\n  var thav = (tf.hi & 0xFFF) | 0x1000;\n\n  sequence &= 0x3FFF;\n  var cshar = (sequence >>> 8) | 0x80;\n  var csl = sequence & 0xFF;\n\n  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);\n};\n\nUUIDjs.create = function(version) {\n  version = version || 4;\n  return this['_create' + version]();\n};\n\nUUIDjs.fromTime = function(time, last) {\n  last = (!last) ? false : last;\n  var tf = UUIDjs.getTimeFieldValues(time);\n  var tl = tf.low;\n  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'\n  if (last === false) {\n    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);\n  } else {\n    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);\n  }\n};\n\nUUIDjs.firstFromTime = function(time) {\n  return UUIDjs.fromTime(time, false);\n};\nUUIDjs.lastFromTime = function(time) {\n  return UUIDjs.fromTime(time, true);\n};\n\nUUIDjs.fromURN = function(strId) {\n  var r, p = /^(?:urn:uuid:|\\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\\})?$/i;\n  if ((r = p.exec(strId))) {\n    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),\n                            parseInt(r[3], 16), parseInt(r[4], 16),\n                            parseInt(r[5], 16), parseInt(r[6], 16));\n  }\n  return null;\n};\n\nUUIDjs.fromBytes = function(ints) {\n  if (ints.length < 5) {\n    return null;\n  }\n  var str = '';\n  var pos = 0;\n  var parts = [4, 2, 2, 2, 6];\n  for (var i = 0; i < parts.length; i++) {\n    for (var j = 0; j < parts[i]; j++) {\n      var octet = ints[pos++].toString(16);\n      if (octet.length == 1) {\n        octet = '0' + octet;\n      }\n      str += octet;\n    }\n    if (parts[i] !== 6) {\n      str += '-';\n    }\n  }\n  return UUIDjs.fromURN(str);\n};\n\nUUIDjs.fromBinary = function(binary) {\n  var ints = [];\n  for (var i = 0; i < binary.length; i++) {\n    ints[i] = binary.charCodeAt(i);\n    if (ints[i] > 255 || ints[i] < 0) {\n      throw new Error('Unexpected byte in binary data.');\n    }\n  }\n  return UUIDjs.fromBytes(ints);\n};\n\n// Aliases to support legacy code. Do not use these when writing new code as\n// they may be removed in future versions!\nUUIDjs.new = function() {\n  return this.create(4);\n};\nUUIDjs.newTS = function() {\n  return this.create(1);\n};\n\nmodule.exports = UUIDjs;\n",
    "deps": {},
    "hash": "c021d4ef2092a91f1d13059ba105ee46"
  },
  "13": {
    "id": 13,
    "index": 13,
    "file": "/Users/tmpethick/Business/Projects/turtlespace/node_modules/yocto/src/yocto.js",
    "source": "/*jshint browser:true, strict:true es5:true*/\n// yocto.js 0.0.1 - (c) 2012 Trygve Lie - MIT license.\n\n\n// # Internals\n//\n//\n// ## - Object storage and object structure\n//\n// All objects is stored in _one_ array which is only allowed to contain objects. Upon insertion\n// into the array all non object types is declined by a filter method.\n//\n// There is no restrictions on the structure of the objects stored in the array so the array can\n// hold a wide range of different objects. This does not affect the matching process.\n//\n// The matching process is done by comparing object keys and values in a template object and each\n// object in the array. This matching process does only a shallow match. Deeply nested object\n// values will not be compared. Though, doing a deep object structure match can be done by the\n// user by providing a dedicated function to a template key to do the match.\n// Doing a deep object structure match would probably be overkill for most usecases of yocto so\n// doing so is delibertly handed over to the user to implement here/him self.\n//\n//\n// ## - Chaining and function composition\n//\n// The public API can be chained and the chain is terminated by a callback to a, preferly the\n// last, method in the chain.\n// Since all objects are stored in an array retreiving the requested arrays will involve looping\n// over all objects to match those whit a template. The result of such a request will be a new\n// list with the matching objects which the user possible would like to do something upon each\n// object. This is a possible double loop.\n//\n// To reduce possible double loops, functions are upon chaining composed into one function which\n// will run inside _one_ loop upon termination of a chain.\n//\n// When composing function one parameter is sendt as function parameter to a function and then\n// returned again. The returned value will then be passed on as function paramter to the next\n// function in the composition.\n//\n// In yocto we pass one object which looks like this through to all composed functions:\n// {\n//    objects     : [],\n//    object      : undefined,\n//    result      : [],\n//    index       : 0,\n//    template    : {},\n//    match       : true,\n//    onEach      : undefined\n// }\n//\n// Each function in the composition can then manipulate this object before its passed on to the\n// next function.\n\n\n(function(exports){\n\n    \"use strict\";\n\n\n    function Yocto(options) {\n\n        var config      = {\n                name : 'yocto'\n            },\n\n            observers   = [],\n\n            chain       = [],\n\n            core        = {\n                objects         : [],\n                uuids           : {},\n                updated         : -1,\n\n                template        : {},\n                doHashLookup    : false,\n\n                object          : undefined,\n                index           : 0,\n                match           : false,\n                onEach          : undefined,\n\n                result          : [],\n                onEnd           : undefined\n            };\n\n\n\n        // Environment checks\n\n        var has = {\n            storage : supportsLocalStorage()\n        };\n\n\n\n        // Convenient \"is\" checks\n        // These checks is also passed on to any functions in a template\n\n        var is = {\n            arr     : function(value) {return value instanceof Array;},\n            obj     : function(value) {return value instanceof Object;},\n            fn      : function(value) {return typeof value === 'function';},\n            str     : function(value) {return typeof value === 'string';},\n            num     : function(value) {return typeof value === 'number';},\n            empty   : function(obj) {\n                if (obj === null) {return true;}\n                if (is.arr(obj) || is.str(obj)) {return obj.length === 0;}\n                if (is.obj(obj)) {return Object.keys(obj).length === 0;}\n                return true;\n            }\n        };\n\n\n\n        // Is localstorage supported in the run time\n\n        function supportsLocalStorage() {\n            var tmp = '__ytest';\n            try {\n                localStorage.setItem(tmp,tmp);\n                localStorage.removeItem(tmp);\n                return true;\n            } catch(e) {\n                return false;\n            }\n        }\n\n\n\n        // Reset additional properties on the core object\n\n        function reset(coreObj) {\n            coreObj.template        = {};\n            coreObj.doHashLookup    = false;\n\n            coreObj.object          = undefined;\n            coreObj.index           = 0;\n            coreObj.match           = false;\n            coreObj.onEach          = undefined;\n\n            coreObj.result          = [];\n            coreObj.onEnd           = undefined;\n        }\n\n\n\n        // Compose an array of composition functions into one function\n\n        function compose() {\n\n            var funcs = arguments;\n\n            return function() {\n                var i       = 0,\n                    l       = funcs.length,\n                    args    = arguments;\n\n                for (i = 0; i < l; i += 1) {\n                    args = [funcs[i].apply(this, args)];\n                }\n\n                return args[0];\n            };\n\n        }\n\n\n        // Composition function for matching an object with a template based on key matching\n\n        function keysMatch(coreObj) {\n            coreObj.match = Object.keys(coreObj.template).every(function(key) {\n                if (is.fn(coreObj.template[key])) {\n                    return coreObj.template[key].call(this, coreObj.object[key], is);\n\n                } else {\n                    return coreObj.object[key] === coreObj.template[key];\n\n                }\n            });\n            return coreObj;\n        }\n\n\n        // Composition function for removing an object from the storage array\n\n        function arrayRemove(coreObj) {\n            if (coreObj.match) {\n                coreObj.object = coreObj.objects.splice(coreObj.index, 1)[0];\n                coreObj.index--;\n            }\n\n            // Autosave all objects to localstorage\n            if (is.obj(config.autosave)) {\n                save(config.autosave, coreObj.objects);\n            }\n\n            return coreObj;\n        }\n\n\n        // Remove an object from the object hash\n\n        function hashRemove(coreObj) {\n            var key = coreObj.template[config.uuid];\n            delete coreObj.uuids[key];\n            return coreObj;\n        }\n\n\n        // Append an object to the object hash\n\n        function hashAppend(conf, obj, coreObj) {\n            if (conf.uuid) {\n                coreObj.uuids[obj[conf.uuid]] = obj;\n            }\n            return coreObj;\n        }\n\n\n        // Composition function for executing onEach callback\n\n        function doOnEach(coreObj) {\n            if (coreObj.match) {\n                coreObj.onEach.call(null, coreObj.object);\n            }\n            return coreObj;\n        }\n\n\n        // Look up objects in the object array\n        // Takes the array of composition functions and runs the composed function in one loop\n\n        function arrayLookup(coreObj, chainArr) {\n\n            var composedFunction    = compose.apply(null, chainArr),\n                runOnResult         = (coreObj.result.length !== 0) || false,\n                objs                = runOnResult ? coreObj.result : coreObj.objects,\n                result              = [],\n                l                   = objs.length;\n\n            for (coreObj.index = 0; coreObj.index < l; coreObj.index += 1) {\n                coreObj.object   = objs[coreObj.index];\n\n                composedFunction(coreObj);\n\n                if (coreObj.match) {\n\n                    // When taking objects out of the tuple we need to compensate for\n                    // the objects taken out to prevent out of bound error.\n                    // This compensation should only be done on the tuple object array.\n                    if (!runOnResult && l != objs.length) {\n                        l = objs.length;\n                    }\n\n                    result.push(coreObj.object);\n                }\n            }\n\n            coreObj.result = result;\n\n            if (coreObj.onEnd) {\n                coreObj.onEnd.call(null, coreObj.result);\n            }\n\n            return coreObj;\n        }\n\n\n        // Look up an object in the uuid hash\n\n        function hashLookup(coreObj, chainArr) {\n\n            var composedFunction    = compose.apply(null, chainArr),\n                uuid                = coreObj.template[config.uuid];\n\n            coreObj.object = coreObj.uuids[uuid] ? coreObj.uuids[uuid] : {};\n            composedFunction(coreObj);\n\n            if (coreObj.match) {\n                coreObj.result.push(coreObj.object);\n            }\n\n            if (coreObj.onEnd) {\n                coreObj.onEnd.call(null, coreObj.result);\n            }\n\n            return coreObj;\n        }\n\n\n        // Switch between looking up in the object array or object hash\n\n        function lookup(coreObj, chainArr) {\n            if (config.uuid && coreObj.template[config.uuid] && coreObj.doHashLookup) {\n                return hashLookup(coreObj, chainArr);\n            } else {\n                return arrayLookup(coreObj, chainArr);\n            }\n        }\n\n\n        // Set storage type to use base on a config object\n\n        function setStorageType(conf) {\n            if (conf && conf.type === 'session') {\n                return 'sessionStorage';\n            } else {\n                return 'localStorage';\n            }\n        }\n\n\n        // Save objects to localstorage\n\n        function save(conf, objs) {\n            var type = setStorageType(conf);\n\n            if (conf && is.str(conf.name) && has.storage) {\n                window[type].setItem(conf.name, JSON.stringify({\n                    creator     : conf.name,\n                    timestamp   : +new Date(),\n                    objects     : objs\n                }));\n            }\n        }\n\n\n        // Append a timestamp to an object\n\n        function setTimestamp(conf, obj, coreObj) {\n            if (conf.timestamp && !obj[conf.timestamp]) {\n                obj[conf.timestamp] = coreObj.updated;\n            }\n        }\n\n\n        function observerMatch(ev, objs) {\n            var i = 0,\n                l = objs.length,\n                w = 0;\n\n            function match(template, obj){\n                return Object.keys(template).every(function(key) {\n                    if (is.fn(template[key])) {\n                        return template[key].call(this, obj[key], is);\n                    } else {\n                        return obj[key] === template[key];\n                    }\n                });\n            }\n\n            for (i = 0; i < l; i += 1) {\n                w = observers.length;\n                while(w--) {\n                    if (match(observers[w].template, objs[i])) {\n                        observers[w].fn.call(null, ev, objs[i]);\n                    }\n                }\n            }\n        }\n\n\n        // Get the highest number of a key in an array\n\n        function getHighestNumber(arr, key) {\n            return Math.max.apply(Math, arr.map(function(obj){\n                return obj[key];\n            }));\n        }\n\n\n        // Set config - Do not allow override of \"name\"\n\n        if (is.obj(options) && is.obj(config)) {\n            Object.keys(options).every(function(key){\n                if (key !== 'name') {\n                    config[key] = options[key];\n                }\n                return true;\n            });\n        }\n\n\n\n        // Public methods\n\n        return {\n\n            // Put a single object or an array of objects into the database\n\n            put : function(obj, onSuccess) {\n\n                var i   = 0,\n                    l   = 0;\n\n                core.match = true;\n                core.updated = +new Date();\n\n                // Array of objects applied\n                if (is.arr(obj)) {\n\n                    // Filter out non object entries.\n                    obj = obj.filter(function(element){\n                        return (is.obj(element) && !is.arr(element));\n                    });\n\n                    if (config.uuid || config.timestamp) {\n                        l = obj.length;\n                        for (i = 0; i < l; i += 1) {\n                            setTimestamp(config, obj[i], core);\n                            hashAppend(config, obj[i], core);\n                        }\n                    }\n\n                    core.objects    = core.objects.concat(obj);\n                    core.result     = core.result.concat(obj);\n                }\n\n                // Single object applied\n                if (is.obj(obj) && !is.arr(obj)) {\n                    setTimestamp(config, obj, core);\n                    hashAppend(config, obj, core);\n\n                    core.objects.push(obj);\n                    core.result.push(obj);\n                }\n\n                // Autosave all objects to localstorage\n                if (is.obj(config.autosave)) {\n                    save(config.autosave, core.objects);\n                }\n\n                // Run the result trough the observers\n                observerMatch('put', core.result);\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    onSuccess.call(this, core.result);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Get object(s) from the database based on a template object\n\n            get : function(template, onSuccess) {\n                core.template       = template || {};\n                core.doHashLookup   = true;\n\n                chain.push(keysMatch);\n\n                core.onEnd = onSuccess;\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    lookup(core, chain);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Takes matching objects out of the database\n\n            take : function(template, onSuccess) {\n                core.template = template || {};\n                chain.push(keysMatch);\n                chain.push(arrayRemove);\n                chain.push(hashRemove);\n\n                core.onEnd = function(result){\n                    if(onSuccess && is.fn(onSuccess)) {\n                        onSuccess(result);\n                    }\n\n                    // Run the result trough the observers\n                    observerMatch('take', result);\n                };\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    lookup(core, chain);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Loop over each object in a returned list of objects\n\n            each : function(onEach) {\n                chain.push(doOnEach);\n\n                core.onEach = onEach;\n\n                if (onEach && is.fn(onEach)) {\n                    lookup(core, chain);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Drop all database records in memory.\n\n            drop : function(onSuccess) {\n                core.objects.splice(0, core.objects.length);\n                core.uuids = {};\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    onSuccess.call(null);\n                    reset(core);\n                    chain = [];\n                }\n                return this;\n            },\n\n\n            // Drop all database records in memory and in localStorage.\n            // Takes the following object as configuration:\n            // {\n            //     type : 'local' || 'session'\n            //     name : ''\n            // }\n\n            destroy : function(conf, onSuccess) {\n                var type    = setStorageType(conf);\n\n                if (conf && is.str(conf.name) && has.storage) {\n                    window[type].removeItem(conf.name);\n                }\n\n                this.drop(onSuccess);\n\n                return this;\n            },\n\n\n            // Sort a returned list of objects based on a objects property name\n\n            sort : function(key, onSuccess) {\n\n                core.onEnd = function(){\n                    core.result = core.result.sort(function sortByObjectKey(object1, object2) {\n                        var key1 = '',\n                            key2 = '';\n\n                        if (is.obj(object1) && is.obj(object2) && object1 && object2) {\n                            key1 = object1[key];\n                            key2 = object2[key];\n                            if (key1 === key2) {\n                                return object1;\n                            }\n                            if (typeof key1 === typeof key2) {\n                                return key1 < key2 ? -1 : 1;\n                            }\n                        }\n                    });\n                };\n\n                lookup(core, chain);\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    onSuccess.call(null, core.result);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Save a list of records to localstorage\n            // Takes the following object as configuration:\n            // {\n            //     type : 'local' || 'session'\n            //     name : ''\n            // }\n\n            save : function(conf, onSuccess) {\n\n                core.onEnd = function(){\n                    save(conf, core.result);\n\n                    if (onSuccess && is.fn(onSuccess)) {\n                        onSuccess.call(null, core.result);\n                    }\n                };\n\n                if (onSuccess && is.fn(onSuccess)) {\n                    lookup(core, chain);\n                    reset(core);\n                    chain = [];\n                }\n\n                return this;\n            },\n\n\n            // Load a list of records from localstorage\n            // Takes the following object as configuration:\n            // {\n            //     type : 'local' || 'session'\n            //     name : ''\n            // }\n\n            load : function(conf, onLoaded) {\n\n                var type        = setStorageType(conf),\n                    loadedData  = '',\n                    parsedData  = {};\n\n                if (conf && is.str(conf.name) && has.storage) {\n                    loadedData = window[type].getItem(conf.name);\n                    parsedData = JSON.parse(loadedData);\n                }\n\n                this.put(is.empty(parsedData) ? [] : parsedData.objects, onLoaded);\n\n                return this;\n            },\n\n\n            observe : function(template, onMatch){\n                observers.push({\n                    template : template,\n                    fn : onMatch\n                });\n                return this;\n            },\n\n\n            unobserve : function(template) {\n                var i = observers.length;\n                while(i--) {\n                    if (observers[i].template === template) {\n                        observers.splice(i,1);\n                    }\n                }\n                return this;\n            },\n\n\n            // Returns misc status information about the database\n\n            status : function(onSuccess) {\n                onSuccess.call(null, {\n                    count   : core.objects.length,\n                    updated : core.updated,\n                    latest  : config.timestamp ? getHighestNumber(core.objects, config.timestamp) : -1\n                });\n\n                return this;\n            }\n\n        };\n\n    }\n\n\n    exports.db = function createYocto(options) {\n        return new Yocto(options);\n    };\n\n\n})(typeof exports === 'undefined' ? this.yocto = {}: exports);",
    "deps": {},
    "hash": "4af5806c220af43ffebb17883768ae4f"
  }
}, 1);